<!DOCTYPE html>
<html lang="zh">
   <head>
       <meta charset="UTF-8">
       <meta name="viewport" content="width=device-width, initial-scale=1.0">
       <meta http-equiv="X-UA-Compatible" content="ie=edge">
       <title>作用域，预解析和执行上下文</title>
   </head>
   <body>
       <script type="text/javascript">
        /*
        作用域：变量的使用范围，静态的（编写代码的时候就已经确定了）
            1.全局作用域：函数外部变量的使用范围
            2.局部作用域：函数内变量的使用范围（一个函数就是一个作用域）
            3.块级作用域（ES6新增）：const，let
        作用域和执行上下文：
            1.全局作用域之外每个函数都会创建自己的作用域，作用域在函数定义的时候就已经确定了，而不是函数调用的时候
            2.全局执行上下文环境在作用域确定之后，js马上执行之前创建
            3.函数执行上下文环境是在调用函数时，函数体代码执行之前创建
            4.作用域是静态的，只要函数定义好了就一直存在，且不会变化
            5.执行上下文是动态的，调用函数的时候创建，函数调用结束时执行上下文环境就会被释放
            6.上下文环境（对象）是从属于所在的作用域
            7.全局上下文环境--->全局作用域
            8.作用域链：
                1）用来决定代码的执行范围，变量的作用范围
                2）作用域链是如何产生的
                    - 函数在定义的时候自动添加一个属性'[[Scopes]]'，该属性保存的是其上级作用域链
                    - 当函数执行的时候，进入上下文执行环境，将创建的变量对象添加到'[[Scopes]]'数组的第一个位置，形成新的数组
                3）查找变量的规则
                    - 现在当前作用域变量对象中查找，找到则使用
                    - 如果没有则沿着作用域链的数组去上级作用域中的变量对象中查找
                    - 找到就返回对应的值，如果没有找到继续向上查找，直到找到最后一个变量对象（全局的变量对象），如果没有则报错
        */

        
           

        /*
        js引擎在js代码正式执行之前会做一些预解析的操作
            1.先找关键字var，function
            2.找到var以后将var后面的变量提前声明，但是不赋值
            3.找到function后将function后面的函数提前声明，但是不赋值，也就是说函数在解析之前已经定义完毕了
            4.变量的提升-----> 浏览器在解析js代码之前，先把变量的声明提升
            5.函数的提升：
                * 浏览器在解析js代码之前，先把函数的声明提升
                * 函数提升---->变量提升，同名的变量忽略
            6.注意：
                f2();
                f2 = function(){}
                会报错，因为f2是undefined
            7.预解析：全局预解析和局部预解析

        */
        a();
        var a = 100;
        function a(){
            console.log('函数');
        }
        console.log(a);
        // 上面的解析完之后---相当于下面的代码
        function a(){
            console.log('函数');
        }
        var a;
        a();
        a = 100;
        console.log(a);


        /*
        执行上下文（动态的）：就是一个代码的执行环境（全局执行上下文和函数执行上下文，eval函数执行上下文）
        1.执行上下文概念：代表了代码的执行环境，包含：执行环境，变量对象，this，作用域链
        2.流程：
            - js引擎在js代码正式执行前会先创建一个执行环境
            - 进入该环境后会创建一个变量对象，该对象用于收集：变量，函数，函数的参数，this
            - 找关键字var，function
            - 确认this
            - 创建作用域链
        3.在全局代码执行之前，js引擎就会创建一个栈来存储管理所有的执行上下文
        4.在全局执行上下文（window）确定后，将其添加到栈中（压栈）
        5.在函数执行上下文创建后，将其添加到栈中（压栈）
        6.在当前函数执行完毕后，将栈顶的对象移除（出栈）
        7.当所有的代码执行完毕后，栈中只剩下window
        8.重点：执行上下文是动态创建的，尤其是针对函数，每调用一次函数都会创建一次执行上下文

        总结：当代码要执行，但是还没有执行，或者将要执行，在预解析之后，此时出现了全局执行上下文环境（全局执行上下文），
        创建了一个变量对象，用来收集var，function，函数参数，确定this的指向，默认全局执行上下文是确定了this是window，
        这个变量对象会被压入到栈中（全局执行上下文的变量对象在栈中的最下面），如果出现了函数调用，此时出现了局部执行上下文环境（局部执行上下文），
        再次创建一个变量对象，用来收集var，function，函数参数，改变this指向，这个变量对象会被再次压入到栈中，在全局执行上下文变量对象的上面，
        如果当前函数调用完毕，此时出栈（把局部执行上下文对象变量清除），一次弹出变量对象，就结束了。
        */


        //现有作用域，然后才有预解析，最后才有执行上下文
       </script>
   </body>
</html>